; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -opaque-pointers -dse-optimize-across-loops -passes=dse -S | FileCheck %s

; These tests check if store in %loop because memory intrinsic in %exit overwrites it

; Check if store in %loop is removed because memory intrinsic in
; %exit overwrites it
; TODO: Store is not removed even if it is redundant
define void @post_dom_memset(ptr nocapture %ptr, i32 %n) local_unnamed_addr #0 {
; CHECK-LABEL: @post_dom_memset(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ENTRY_COND:%.*]] = icmp eq i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[ENTRY_COND]], label [[EXIT:%.*]], label [[PREHEADER:%.*]]
; CHECK:       preheader:
; CHECK-NEXT:    [[N_CAST:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       preexit:
; CHECK-NEXT:    [[PREEXIT_LEN:%.*]] = shl nuw nsw i64 [[N_CAST]], 2
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[LEN:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[PREEXIT_LEN]], [[PREEXIT:%.*]] ]
; CHECK-NEXT:    tail call void @llvm.memset.p0.i64(ptr align 4 [[PTR:%.*]], i8 0, i64 [[LEN]], i1 false)
; CHECK-NEXT:    ret void
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[PREHEADER]] ], [ [[IV_1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IDX:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[IV]]
; CHECK-NEXT:    store i32 1, ptr [[IDX]], align 4
; CHECK-NEXT:    [[IV_1]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp eq i64 [[IV_1]], [[N_CAST]]
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[PREEXIT]], label [[LOOP]]
;
entry:
  %entry.cond = icmp eq i32 %n, 0
  br i1 %entry.cond, label %exit, label %preheader

preheader:                                                ; preds = %entry
  %n.cast = zext i32 %n to i64
  br label %loop

preexit:                                                ; preds = %loop
  %preexit.len = shl nuw nsw i64 %n.cast, 2
  br label %exit

exit:                                                ; preds = %preexit, %entry
  %len = phi i64 [ 0, %entry ], [ %preexit.len, %preexit ]
  tail call void @llvm.memset.p0i8.i64(ptr align 4 %ptr, i8 0, i64 %len, i1 false)
  ret void

loop:                                               ; preds = %preheader, %loop
  %iv = phi i64 [ 0, %preheader ], [ %iv.1, %loop ]
  %idx = getelementptr inbounds i32, ptr %ptr, i64 %iv
  store i32 1, ptr %idx, align 4
  %iv.1 = add nuw nsw i64 %iv, 1
  %loop.cond = icmp eq i64 %iv.1, %n.cast
  br i1 %loop.cond, label %preexit, label %loop
}

declare void @llvm.memset.p0i8.i64(ptr nocapture writeonly, i8, i64, i1 immarg)

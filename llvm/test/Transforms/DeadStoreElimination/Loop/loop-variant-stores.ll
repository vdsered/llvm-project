; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -opaque-pointers -dse-optimize-across-loops -passes=dse -S | FileCheck %s

; These tests check if store is removed because there is overwrite in another
; loop


; The simplest case when one store overwrites another when they are in different loops
; Store in %loop.2 must cause removal of store in %loop.1
define void @overwrite_store(ptr nocapture %ptr, i32 %n) {
; CHECK-LABEL: @overwrite_store(
; CHECK-NEXT:    [[COND:%.*]] = icmp sgt i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[PREHEADER1:%.*]], label [[EXIT:%.*]]
; CHECK:       preheader1:
; CHECK-NEXT:    [[N_ZEXT1:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP_1:%.*]]
; CHECK:       guard:
; CHECK-NEXT:    br i1 [[COND]], label [[PREHEADER2:%.*]], label [[EXIT]]
; CHECK:       preheader2:
; CHECK-NEXT:    [[N_ZEXT2:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.1:
; CHECK-NEXT:    [[LOOP_1_IV:%.*]] = phi i64 [ 0, [[PREHEADER1]] ], [ [[LOOP_1_IV_1:%.*]], [[LOOP_1]] ]
; CHECK-NEXT:    [[LOOP_1_IV_1]] = add nuw nsw i64 [[LOOP_1_IV]], 1
; CHECK-NEXT:    [[LOOP_1_COND:%.*]] = icmp eq i64 [[LOOP_1_IV_1]], [[N_ZEXT1]]
; CHECK-NEXT:    br i1 [[LOOP_1_COND]], label [[GUARD:%.*]], label [[LOOP_1]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
; CHECK:       loop.2:
; CHECK-NEXT:    [[LOOP_2_IV:%.*]] = phi i64 [ 0, [[PREHEADER2]] ], [ [[LOOP_2_IV_1:%.*]], [[LOOP_2]] ]
; CHECK-NEXT:    [[LOOP_2_IDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 [[LOOP_2_IV]]
; CHECK-NEXT:    store i32 3, ptr [[LOOP_2_IDX]], align 4
; CHECK-NEXT:    [[LOOP_2_IV_1]] = add nuw nsw i64 [[LOOP_2_IV]], 1
; CHECK-NEXT:    [[LOOP_2_COND:%.*]] = icmp eq i64 [[LOOP_2_IV_1]], [[N_ZEXT2]]
; CHECK-NEXT:    br i1 [[LOOP_2_COND]], label [[EXIT_LOOPEXIT:%.*]], label [[LOOP_2]]
;
  %cond = icmp sgt i32 %n, 0
  br i1 %cond, label %preheader1, label %exit

preheader1:                                       ; preds = %entry
  %n.zext1 = zext i32 %n to i64
  br label %loop.1

guard:                                            ; preds = %loop.1
  br i1 %cond, label %preheader2, label %exit

preheader2:                                       ; preds = %guard
  %n.zext2 = zext i32 %n to i64
  br label %loop.2

loop.1:                                           ; preds = %loop.1, %preheader1
  %loop.1.iv = phi i64 [ 0, %preheader1 ], [ %loop.1.iv.1, %loop.1 ]
  %loop.1.idx = getelementptr inbounds i32, ptr %ptr, i64 %loop.1.iv
  store i32 2, ptr %loop.1.idx, align 4
  %loop.1.iv.1 = add nuw nsw i64 %loop.1.iv, 1
  %loop.1.cond = icmp eq i64 %loop.1.iv.1, %n.zext1
  br i1 %loop.1.cond, label %guard, label %loop.1

exit.loopexit:                                    ; preds = %loop.2
  br label %exit

exit:                                             ; preds = %exit.loopexit, %guard, %entry
  ret void

loop.2:                                           ; preds = %loop.2, %preheader2
  %loop.2.iv = phi i64 [ 0, %preheader2 ], [ %loop.2.iv.1, %loop.2 ]
  %loop.2.idx = getelementptr inbounds i32, ptr %ptr, i64 %loop.2.iv
  store i32 3, ptr %loop.2.idx, align 4
  %loop.2.iv.1 = add nuw nsw i64 %loop.2.iv, 1
  %loop.2.cond = icmp eq i64 %loop.2.iv.1, %n.zext2
  br i1 %loop.2.cond, label %exit.loopexit, label %loop.2
}

; Check if store in %loop.1.header is removed even when there are more than one path
; to %loop.1.latch
define void @must_execute_store(ptr %ptr, i32 %n, i1 %x) {
; CHECK-LABEL: @must_execute_store(
; CHECK-NEXT:    [[COND:%.*]] = icmp sgt i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[PREHEADER1:%.*]], label [[EXIT:%.*]]
; CHECK:       preheader1:
; CHECK-NEXT:    [[N_ZEXT1:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP_1_HEADER:%.*]]
; CHECK:       guard:
; CHECK-NEXT:    br i1 [[COND]], label [[PREHEADER2:%.*]], label [[EXIT]]
; CHECK:       preheader2:
; CHECK-NEXT:    [[N_ZEXT2:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.1.header:
; CHECK-NEXT:    [[LOOP_1_IV:%.*]] = phi i64 [ 0, [[PREHEADER1]] ], [ [[LOOP_1_IV_1:%.*]], [[LOOP_1_LATCH:%.*]] ]
; CHECK-NEXT:    br i1 [[X:%.*]], label [[LOOP_1_DUMMY:%.*]], label [[LOOP_1_DUMMY2:%.*]]
; CHECK:       loop.1.dummy:
; CHECK-NEXT:    tail call void @dummy1()
; CHECK-NEXT:    br label [[LOOP_1_LATCH]]
; CHECK:       loop.1.dummy2:
; CHECK-NEXT:    tail call void @dummy2()
; CHECK-NEXT:    br label [[LOOP_1_LATCH]]
; CHECK:       loop.1.latch:
; CHECK-NEXT:    [[LOOP_1_IV_1]] = add nuw nsw i64 [[LOOP_1_IV]], 1
; CHECK-NEXT:    [[LOOP_1_COND:%.*]] = icmp eq i64 [[LOOP_1_IV_1]], [[N_ZEXT1]]
; CHECK-NEXT:    br i1 [[LOOP_1_COND]], label [[GUARD:%.*]], label [[LOOP_1_HEADER]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
; CHECK:       loop.2:
; CHECK-NEXT:    [[LOOP_2_IV:%.*]] = phi i64 [ 0, [[PREHEADER2]] ], [ [[LOOP_2_IV_1:%.*]], [[LOOP_2]] ]
; CHECK-NEXT:    [[LOOP_2_IDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 [[LOOP_2_IV]]
; CHECK-NEXT:    store i32 3, ptr [[LOOP_2_IDX]], align 4
; CHECK-NEXT:    [[LOOP_2_IV_1]] = add nuw nsw i64 [[LOOP_2_IV]], 1
; CHECK-NEXT:    [[LOOP_2_COND:%.*]] = icmp eq i64 [[LOOP_2_IV_1]], [[N_ZEXT2]]
; CHECK-NEXT:    br i1 [[LOOP_2_COND]], label [[EXIT_LOOPEXIT:%.*]], label [[LOOP_2]]
;
%cond = icmp sgt i32 %n, 0
br i1 %cond, label %preheader1, label %exit

preheader1:                                       ; preds = %entry
%n.zext1 = zext i32 %n to i64
br label %loop.1.header

guard:                                            ; preds = %loop.1.latch
br i1 %cond, label %preheader2, label %exit

preheader2:                                       ; preds = %guard
%n.zext2 = zext i32 %n to i64
br label %loop.2

loop.1.header:                                    ; preds = %loop.1.latch, %preheader1
%loop.1.iv = phi i64 [ 0, %preheader1 ], [ %loop.1.iv.1, %loop.1.latch ]
%loop.1.idx = getelementptr inbounds i32, ptr %ptr, i64 %loop.1.iv
store i32 2, ptr %loop.1.idx, align 4
br i1 %x, label %loop.1.dummy, label %loop.1.dummy2

loop.1.dummy:                                     ; preds = %loop.1.header
tail call void @dummy1()
br label %loop.1.latch

loop.1.dummy2:                                    ; preds = %loop.1.header
tail call void @dummy2()
br label %loop.1.latch

loop.1.latch:                                     ; preds = %loop.1.dummy2, %loop.1.dummy
%loop.1.iv.1 = add nuw nsw i64 %loop.1.iv, 1
%loop.1.cond = icmp eq i64 %loop.1.iv.1, %n.zext1
br i1 %loop.1.cond, label %guard, label %loop.1.header

exit.loopexit:                                    ; preds = %loop.2
br label %exit

exit:                                             ; preds = %exit.loopexit, %guard, %entry
ret void

loop.2:                                           ; preds = %loop.2, %preheader2
%loop.2.iv = phi i64 [ 0, %preheader2 ], [ %loop.2.iv.1, %loop.2 ]
%loop.2.idx = getelementptr inbounds i32, ptr %ptr, i64 %loop.2.iv
store i32 3, ptr %loop.2.idx, align 4
%loop.2.iv.1 = add nuw nsw i64 %loop.2.iv, 1
%loop.2.cond = icmp eq i64 %loop.2.iv.1, %n.zext2
br i1 %loop.2.cond, label %exit.loopexit, label %loop.2
}

; Check if store in %loop.1.store is removed even when it does not always execute
define void @not_always_execute(ptr %ptr, i32 %n, i1 %x) {
; CHECK-LABEL: @not_always_execute(
; CHECK-NEXT:    [[COND:%.*]] = icmp sgt i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[PREHEADER1:%.*]], label [[EXIT:%.*]]
; CHECK:       preheader1:
; CHECK-NEXT:    [[N_ZEXT1:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP_1_HEADER:%.*]]
; CHECK:       guard:
; CHECK-NEXT:    br i1 [[COND]], label [[PREHEADER2:%.*]], label [[EXIT]]
; CHECK:       preheader2:
; CHECK-NEXT:    [[N_ZEXT2:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.1.header:
; CHECK-NEXT:    [[LOOP_1_IV:%.*]] = phi i64 [ 0, [[PREHEADER1]] ], [ [[LOOP_1_IV_1:%.*]], [[LOOP_1_LATCH:%.*]] ]
; CHECK-NEXT:    br i1 [[X:%.*]], label [[LOOP_1_STORE:%.*]], label [[LOOP_1_DUMMY2:%.*]]
; CHECK:       loop.1.store:
; CHECK-NEXT:    br label [[LOOP_1_LATCH]]
; CHECK:       loop.1.dummy2:
; CHECK-NEXT:    tail call void @dummy2()
; CHECK-NEXT:    br label [[LOOP_1_LATCH]]
; CHECK:       loop.1.latch:
; CHECK-NEXT:    [[LOOP_1_IV_1]] = add nuw nsw i64 [[LOOP_1_IV]], 1
; CHECK-NEXT:    [[LOOP_1_COND:%.*]] = icmp eq i64 [[LOOP_1_IV_1]], [[N_ZEXT1]]
; CHECK-NEXT:    br i1 [[LOOP_1_COND]], label [[GUARD:%.*]], label [[LOOP_1_HEADER]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
; CHECK:       loop.2:
; CHECK-NEXT:    [[LOOP_2_IV:%.*]] = phi i64 [ 0, [[PREHEADER2]] ], [ [[LOOP_2_IV_1:%.*]], [[LOOP_2]] ]
; CHECK-NEXT:    [[LOOP_2_IDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 [[LOOP_2_IV]]
; CHECK-NEXT:    store i32 3, ptr [[LOOP_2_IDX]], align 4
; CHECK-NEXT:    [[LOOP_2_IV_1]] = add nuw nsw i64 [[LOOP_2_IV]], 1
; CHECK-NEXT:    [[LOOP_2_COND:%.*]] = icmp eq i64 [[LOOP_2_IV_1]], [[N_ZEXT2]]
; CHECK-NEXT:    br i1 [[LOOP_2_COND]], label [[EXIT_LOOPEXIT:%.*]], label [[LOOP_2]]
;
  %cond = icmp sgt i32 %n, 0
  br i1 %cond, label %preheader1, label %exit

preheader1:                                       ; preds = %entry
  %n.zext1 = zext i32 %n to i64
  br label %loop.1.header

guard:                                            ; preds = %loop.1.latch
  br i1 %cond, label %preheader2, label %exit

preheader2:                                       ; preds = %guard
  %n.zext2 = zext i32 %n to i64
  br label %loop.2

loop.1.header:                                    ; preds = %loop.1.latch, %preheader1
  %loop.1.iv = phi i64 [ 0, %preheader1 ], [ %loop.1.iv.1, %loop.1.latch ]
  br i1 %x, label %loop.1.store, label %loop.1.dummy2

loop.1.store:                                     ; preds = %loop.1.header
  %loop.1.idx = getelementptr inbounds i32, ptr %ptr, i64 %loop.1.iv
  store i32 2, ptr %loop.1.idx, align 4
  br label %loop.1.latch

loop.1.dummy2:                                    ; preds = %loop.1.header
  tail call void @dummy2()
  br label %loop.1.latch

loop.1.latch:                                     ; preds = %loop.1.dummy2, %loop.1.store
  %loop.1.iv.1 = add nuw nsw i64 %loop.1.iv, 1
  %loop.1.cond = icmp eq i64 %loop.1.iv.1, %n.zext1
  br i1 %loop.1.cond, label %guard, label %loop.1.header

exit.loopexit:                                    ; preds = %loop.2
  br label %exit

exit:                                             ; preds = %exit.loopexit, %guard, %entry
  ret void

loop.2:                                           ; preds = %loop.2, %preheader2
  %loop.2.iv = phi i64 [ 0, %preheader2 ], [ %loop.2.iv.1, %loop.2 ]
  %loop.2.idx = getelementptr inbounds i32, ptr %ptr, i64 %loop.2.iv
  store i32 3, ptr %loop.2.idx, align 4
  %loop.2.iv.1 = add nuw nsw i64 %loop.2.iv, 1
  %loop.2.cond = icmp eq i64 %loop.2.iv.1, %n.zext2
  br i1 %loop.2.cond, label %exit.loopexit, label %loop.2
}

define void @multiple_stores_in_one_loop(ptr nocapture %ptr, i32 %n) {
; CHECK-LABEL: @multiple_stores_in_one_loop(
; CHECK-NEXT:    [[COND:%.*]] = icmp sgt i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[PREHEADER1:%.*]], label [[EXIT:%.*]]
; CHECK:       preheader1:
; CHECK-NEXT:    [[N_ZEXT1:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP_1:%.*]]
; CHECK:       guard:
; CHECK-NEXT:    br i1 [[COND]], label [[PREHEADER2:%.*]], label [[EXIT]]
; CHECK:       preheader2:
; CHECK-NEXT:    [[N_ZEXT2:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.1:
; CHECK-NEXT:    [[LOOP_1_IV:%.*]] = phi i64 [ 0, [[PREHEADER1]] ], [ [[LOOP_1_IV_1:%.*]], [[LOOP_1]] ]
; CHECK-NEXT:    [[LOOP_1_IV_1]] = add nuw nsw i64 [[LOOP_1_IV]], 1
; CHECK-NEXT:    [[LOOP_1_COND:%.*]] = icmp eq i64 [[LOOP_1_IV_1]], [[N_ZEXT1]]
; CHECK-NEXT:    br i1 [[LOOP_1_COND]], label [[GUARD:%.*]], label [[LOOP_1]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
; CHECK:       loop.2:
; CHECK-NEXT:    [[LOOP_2_IV:%.*]] = phi i64 [ 0, [[PREHEADER2]] ], [ [[LOOP_2_IV_1:%.*]], [[LOOP_2]] ]
; CHECK-NEXT:    [[LOOP_2_IDX:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 [[LOOP_2_IV]]
; CHECK-NEXT:    store i32 3, ptr [[LOOP_2_IDX]], align 4
; CHECK-NEXT:    [[LOOP_2_IV_1]] = add nuw nsw i64 [[LOOP_2_IV]], 1
; CHECK-NEXT:    [[LOOP_2_COND:%.*]] = icmp eq i64 [[LOOP_2_IV_1]], [[N_ZEXT2]]
; CHECK-NEXT:    br i1 [[LOOP_2_COND]], label [[EXIT_LOOPEXIT:%.*]], label [[LOOP_2]]
;
  %cond = icmp sgt i32 %n, 0
  br i1 %cond, label %preheader1, label %exit

preheader1:                                       ; preds = %entry
  %n.zext1 = zext i32 %n to i64
  br label %loop.1

guard:                                            ; preds = %loop.1
  br i1 %cond, label %preheader2, label %exit

preheader2:                                       ; preds = %guard
  %n.zext2 = zext i32 %n to i64
  br label %loop.2

loop.1:                                           ; preds = %loop.1, %preheader1
  %loop.1.iv = phi i64 [ 0, %preheader1 ], [ %loop.1.iv.1, %loop.1 ]
  %loop.1.idx = getelementptr inbounds i32, ptr %ptr, i64 %loop.1.iv
  %loop.1.idx2 = getelementptr inbounds i32, ptr %ptr, i64 %loop.1.iv
  %loop.1.idx3 = getelementptr inbounds i32, ptr %ptr, i64 %loop.1.iv
  store i32 2, ptr %loop.1.idx2, align 4
  store i32 2, ptr %loop.1.idx, align 4
  store i32 2, ptr %loop.1.idx, align 4
  store i32 2, ptr %loop.1.idx2, align 4
  store i32 2, ptr %loop.1.idx, align 4
  store i32 2, ptr %loop.1.idx3, align 4
  %loop.1.iv.1 = add nuw nsw i64 %loop.1.iv, 1
  %loop.1.cond = icmp eq i64 %loop.1.iv.1, %n.zext1
  br i1 %loop.1.cond, label %guard, label %loop.1

exit.loopexit:                                    ; preds = %loop.2
  br label %exit

exit:                                             ; preds = %exit.loopexit, %guard, %entry
  ret void

loop.2:                                           ; preds = %loop.2, %preheader2
  %loop.2.iv = phi i64 [ 0, %preheader2 ], [ %loop.2.iv.1, %loop.2 ]
  %loop.2.idx = getelementptr inbounds i32, ptr %ptr, i64 %loop.2.iv
  store i32 3, ptr %loop.2.idx, align 4
  %loop.2.iv.1 = add nuw nsw i64 %loop.2.iv, 1
  %loop.2.cond = icmp eq i64 %loop.2.iv.1, %n.zext2
  br i1 %loop.2.cond, label %exit.loopexit, label %loop.2
}


declare void @dummy1() #0

declare void @dummy2() #0

attributes #0 = { argmemonly nounwind readnone willreturn }
